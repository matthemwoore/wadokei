<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Wadokei — Rectangular 24h (Port Angeles)</title>

  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root { --black:#000; --white:#fff; }

    html,body{
      height:100%;
      margin:0;
      background:var(--black);
      color:var(--white);
      font-family:"Noto Serif JP", serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .frame { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
    svg { width:100%; height:100%; display:block; }

    .number {
      font-size: 3.2vh;
      font-weight:700;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .hand { stroke-width:6; stroke-linecap: butt; }
  </style>
</head>
<body>
  <div class="frame">
    <!-- Big tall rectangle for TRMNL -->
    <svg id="svg" viewBox="0 0 1000 1600" preserveAspectRatio="xMidYMid meet" aria-label="Rectangular Wadokei 24-hour clock">
      <!-- black background -->
      <rect x="0" y="0" width="1000" height="1600" fill="black"></rect>

      <defs>
        <clipPath id="rectClip">
          <rect x="0" y="0" width="1000" height="1600" />
        </clipPath>
      </defs>

      <!-- Day wedge (global coords). Will be clipped to rectClip -->
      <g clip-path="url(#rectClip)">
        <polygon id="dayWedge" points="" fill="white"></polygon>
      </g>

      <!-- Clock center group (center at 500,800) -->
      <g id="clockGroup" transform="translate(500,800)">
        <!-- Hand group (rotate applied) -->
        <g id="handGroup" transform="rotate(0)">
          <!-- line goes from center outward (negative y) so rotate math matches numbers -->
          <line id="handLine" x1="0" y1="0" x2="0" y2="-850" class="hand" stroke="white"></line>
        </g>

        <!-- Numbers layered above hand -->
        <g id="numbersGroup"></g>
      </g>
    </svg>
  </div>

<script>
/* Rectangular Wadokei — geometric wedge, stretched numbers, correct hand math
   Port Angeles dynamic sunrise/sunset, hand contrasts against underlying sector.
*/

// Config
const LAT = 48.1181;
const LON = -123.4307;
const TIMEZONE = 'America/Los_Angeles';

// SVG geometry
const SVG_W = 1000, SVG_H = 1600;
const CENTER_X = 500, CENTER_Y = 800;
const NUM_RX = 420;  // horizontal ellipse radius for numbers
const NUM_RY = 700;  // vertical ellipse radius for numbers
const HAND_LEN = Math.min(NUM_RX, NUM_RY) * 0.92; // nearly touches numbers
const FAR_R = 6000; // far point for wedge polygon (big enough to reach edges)

// DOM refs
const dayWedge = document.getElementById('dayWedge');
const numbersGroup = document.getElementById('numbersGroup');
const handGroup = document.getElementById('handGroup');
const handLine = document.getElementById('handLine');

// sunrise/sunset fractions (hours 0..24)
let sunriseFrac = 6;
let sunsetFrac = 18;

// Utilities
const SVG_NS = "http://www.w3.org/2000/svg";
function createSVG(tag, attrs={}) { const el = document.createElementNS(SVG_NS, tag); for (const k in attrs) el.setAttribute(k, attrs[k]); return el; }

function fractionalHourInTZ(isoString, tz = TIMEZONE) {
  const d = new Date(isoString);
  const parts = new Intl.DateTimeFormat('en-US', {
    timeZone: tz,
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  }).formatToParts(d);
  let hh=0, mm=0, ss=0;
  for (const p of parts) {
    if (p.type==='hour') hh = parseInt(p.value,10);
    if (p.type==='minute') mm = parseInt(p.value,10);
    if (p.type==='second') ss = parseInt(p.value,10);
  }
  return hh + mm/60 + ss/3600;
}

// Map hour fraction to radians using same scheme as numbers:
// desiredDeg (from +x axis) = (hour/24)*360 + 90
function hourToDeg(hourFrac) {
  return (hourFrac / 24) * 360 + 90;
}
function degToRad(deg) { return deg * Math.PI / 180; }

// isInDaylight helper (handles wrap)
function isInDaylight(hourFrac, sFrac, eFrac) {
  hourFrac = (hourFrac % 24 + 24) % 24;
  sFrac = (sFrac % 24 + 24) % 24;
  eFrac = (eFrac % 24 + 24) % 24;
  if (sFrac <= eFrac) return hourFrac >= sFrac && hourFrac < eFrac;
  return hourFrac >= sFrac || hourFrac < eFrac;
}

// Build wedge polygon in global coords: center plus many far points between start->end
function buildWedgeGlobalPoints(startFrac, endFrac) {
  startFrac = (startFrac % 24 + 24) % 24;
  endFrac = (endFrac % 24 + 24) % 24;

  let startDeg = hourToDeg(startFrac);
  let endDeg = hourToDeg(endFrac);

  // normalize 0..360
  startDeg = ((startDeg % 360) + 360) % 360;
  endDeg = ((endDeg % 360) + 360) % 360;
  if (endDeg <= startDeg) endDeg += 360;

  const step = 2; // degrees
  const pts = [];
  // start with center
  pts.push(`${CENTER_X},${CENTER_Y}`);
  // sweep from start to end (inclusive)
  for (let deg = startDeg; deg <= endDeg + 0.0001; deg += step) {
    const rad = degToRad(deg);
    const x = CENTER_X + Math.cos(rad) * FAR_R;
    const y = CENTER_Y + Math.sin(rad) * FAR_R;
    pts.push(`${x.toFixed(2)},${y.toFixed(2)}`);
  }
  // ensure last point
  const lastRad = degToRad(endDeg);
  pts.push(`${(CENTER_X + Math.cos(lastRad)*FAR_R).toFixed(2)},${(CENTER_Y + Math.sin(lastRad)*FAR_R).toFixed(2)}`);
  return pts.join(' ');
}

// Render numbers stretched on ellipse and color them
function renderNumbers() {
  while (numbersGroup.firstChild) numbersGroup.removeChild(numbersGroup.firstChild);
  for (let h = 0; h < 24; h++) {
    const deg = hourToDeg(h);
    const rad = degToRad(deg);
    const x = Math.cos(rad) * NUM_RX;
    const y = Math.sin(rad) * NUM_RY;
    const txt = createSVG('text', {
      class: 'number',
      x: x,
      y: y,
      fill: isInDaylight(h + 0.0001, sunriseFrac, sunsetFrac) ? 'black' : 'white'
    });
    txt.textContent = String(h);
    numbersGroup.appendChild(txt);
  }
}

// Render wedge and recolor numbers
function renderWedgeAndNumbers() {
  const pts = buildWedgeGlobalPoints(sunriseFrac, sunsetFrac);
  dayWedge.setAttribute('points', pts);
  renderNumbers();
}

// Update the hand: rotation and stroke color contrasting underlying wedge
function updateHand() {
  // get current time in target TZ
  const now = new Date();
  const parts = new Intl.DateTimeFormat('en-US', {
    timeZone: TIMEZONE,
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  }).formatToParts(now);
  let hh=0, mm=0, ss=0;
  for (const p of parts) {
    if (p.type==='hour') hh = parseInt(p.value,10);
    if (p.type==='minute') mm = parseInt(p.value,10);
    if (p.type==='second') ss = parseInt(p.value,10);
  }
  const frac = hh + mm/60 + ss/3600;

  // Compute desiredDeg (same as numbers). For line that initially points up (0,-len),
  // rotation = desiredDeg + 90 puts it in correct orientation so 0->bottom,12->top.
  const desiredDeg = hourToDeg(frac);
  const rotation = desiredDeg + 90;
  handGroup.setAttribute('transform', `rotate(${rotation})`);

  // Hand color: contrast underlying sector at current fractional position
  const onDay = isInDaylight(frac, sunriseFrac, sunsetFrac);
  handLine.setAttribute('stroke', onDay ? 'black' : 'white');

  // also adjust hand length to nearly touch numbers (y2 negative)
  handLine.setAttribute('y2', `${-HAND_LEN}`);
}

// Fetch sunrise/sunset and schedule daily refreshes
async function fetchSunTimes() {
  try {
    const res = await fetch(`https://api.sunrise-sunset.org/json?lat=${LAT}&lng=${LON}&formatted=0`);
    const j = await res.json();
    if (j.status === 'OK') {
      sunriseFrac = fractionalHourInTZ(j.results.sunrise, TIMEZONE);
      sunsetFrac  = fractionalHourInTZ(j.results.sunset, TIMEZONE);
    } else {
      console.warn('Sun API not OK', j);
    }
  } catch (e) {
    console.error('Sun fetch failed', e);
  }
}

// Poll for local date change in target TZ and refresh times
function scheduleDailyRefresh() {
  let lastKey = null;
  const check = () => {
    const now = new Date();
    const parts = new Intl.DateTimeFormat('en-US', { timeZone: TIMEZONE, year:'numeric', month:'2-digit', day:'2-digit' }).formatToParts(now);
    let y=now.getFullYear(), m=now.getMonth()+1, d=now.getDate();
    for (const p of parts) {
      if (p.type==='year') y = parseInt(p.value,10);
      if (p.type==='month') m = parseInt(p.value,10);
      if (p.type==='day') d = parseInt(p.value,10);
    }
    const key = `${y}-${m}-${d}`;
    if (!lastKey) lastKey = key;
    if (key !== lastKey) {
      lastKey = key;
      fetchSunTimes().then(() => renderWedgeAndNumbers());
    }
  };
  setInterval(check, 30000);
}

// Init sequence
async function init() {
  // initial numbers (will recolor once we fetch)
  renderNumbers();

  // fetch sunrise/sunset and render wedge
  await fetchSunTimes();
  renderWedgeAndNumbers();

  // start hand ticking
  updateHand();
  setInterval(updateHand, 1000);

  // daily refresh
  scheduleDailyRefresh();
}

init();

</script>
</body>
</html>
